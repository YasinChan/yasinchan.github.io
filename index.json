[{"content":"\r\n\r\n\r\n\r\n\u003e 从[create-react-app](https://github.com/facebookincubator/create-react-app)官方文档中我们可以看出其暂时还不支持直接导入less或sass。但是通过一些配置，我们是可以在官方脚手架中使用sass/scss/less的。\r\n\u003e\r\n\u003e 以下是官方文档中相关部分的译文，[这里](https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/readme.md#adding-a-css-preprocessor-sass-less-etc)是原文。\r\n\r\n---\r\n\r\n**译文：**\r\n## 添加css预处理器（sass，less等）\r\n\r\n通常，我们建议您不要在不同的组件之间重复使用相同的css类。例如，我们建议您创建一个具有自己的`.button`样式的类似`\u003cacceptbutton\u003e`和`\u003crejectbutton\u003e`可以呈现（但不是继承）出的功能的`\u003cbutton\u003e`组件，而不是在`\u003cacceptbutton\u003e`和`\u003crejectbutton\u003e`组件中直接使用`.button` css类。 \r\n\r\n通过这条规则可以看出css预处理器好像不太有用，因为这些功能可以被拥有诸如混合和嵌套之类的功能的组件所替代。当然，如果您发现它有价值，当然可以集成css预处理器。下面，我们将使用sass来演示，同样您也可以使用less或别的选择。 \r\n\r\n首先，我们来安装sass的命令行界面：\r\n\r\n```\r\nnpm install node-sass-chokidar --save-dev\r\n```\r\n\r\n然后在`package.json`中，将以下行添加到`scripts`中：\r\n\r\n```\r\n   \"scripts\": {\r\n+    \"build-css\": \"node-sass-chokidar src/ -o src/\",\r\n+    \"watch-css\": \"npm run build-css \u0026\u0026 node-sass-chokidar src/ -o src/ --watch --recursive\",\r\n     \"start\": \"react-scripts start\",\r\n     \"build\": \"react-scripts build\",\r\n     \"test\": \"react-scripts test --env=jsdom\",\r\n```\r\n\r\n\u003e note：在使用不同的预处理器时，请根据预处理器的文档替换`build-css`和`watch-css`命令。\r\n\r\n现在，您可以将`src/app.css`重命名为`src/app.scss`并运行`npm run watch-css`。`watch-css`将在src子目录中找到每个sass文件，并在其旁边创建一个相应的css文件，在我们的例子中覆盖`src/app.css`。由于`src/app.js`仍然 improt `src/app.css`，所以样式同样成为您的应用程序的一部分。您现在可以编辑`src/app.scss`，同时会生成相应的`src/app.css`。\r\n\r\n要在sass文件之间共享变量，您可以使用sass导入。例如，`src/app.scss`和其他组件样式文件可以通过`@import “./shared.scss”;`来实现变量的定义共享。\r\n\r\n要在不使用相对路径的情况下导入文件，可以在`package.json`中的命令中添加`--include-path`选项。\r\n\r\n```\r\n\"build-css\": \"node-sass-chokidar --include-path ./src --include-path ./node_modules src/ -o src/\",\r\n\"watch-css\": \"npm run build-css \u0026\u0026 node-sass-chokidar --include-path ./src --include-path ./node_modules src/ -o src/ --watch --recursive\",\r\n```\r\n\r\n这样可以让您像以下这样导入\r\n\r\n```\r\n@import 'styles/_colors.scss'; // assuming a styles directory under src/\r\n@import 'nprogress/nprogress'; // importing a css file from the nprogress node module\r\n```\r\n\r\n此时，您可能想从源代码控件中移除所有的css文件，于是您可以将`src/**/*.css`添加到`.gitignore`文件中来实现。将构建的文件保留在源代码控制之外是一个很好的做法。\r\n\r\n作为最后一步，您可能会发现使用`npm start`自动运行`watch-css`，同时将运行`build-css`作为`npm run build`的一部分会更加方便。您可以使用`\u0026\u0026`运算符顺序执行两个脚本。但是，并行运行两个脚本没有跨平台的方式，所以我们将为此安装一个包：\r\n\r\n```\r\nnpm install --save-dev npm-run-all\r\n```\r\n\r\n然后，我们可以改变`scripts`中的`start`和`build`来包括css预处理器命令：\r\n\r\n```\r\n   \"scripts\": {\r\n     \"build-css\": \"node-sass-chokidar src/ -o src/\",\r\n     \"watch-css\": \"npm run build-css \u0026\u0026 node-sass-chokidar src/ -o src/ --watch --recursive\",\r\n-    \"start\": \"react-scripts start\",\r\n-    \"build\": \"react-scripts build\",\r\n+    \"start-js\": \"react-scripts start\",\r\n+    \"start\": \"npm-run-all -p watch-css start-js\",\r\n+    \"build\": \"npm run build-css \u0026\u0026 react-scripts build\",\r\n     \"test\": \"react-scripts test --env=jsdom\",\r\n     \"eject\": \"react-scripts eject\"\r\n   }\r\n```\r\n\r\n现在运行`run npm`和`npm run build`同样构建了sass文件。\r\n\r\n**为什么使用 node-sass-chokidar?**\r\n\r\n通过`issues`中的反映我们发现`node-sass`具有以下问题：\r\n\r\n- 在某些情况下，`node-sass -watch`被报告在某些情况下会出现性能问题，包括在虚拟机中或使用docker时出现。\r\n- 无限样式编译 [#1939](https://github.com/facebookincubator/create-react-app/issues/1939)\r\n- `node-sass`被报告在检测目录中的新文件时出现问题[#1891](https://github.com/sass/node-sass/issues/1891)\r\n\r\n所以`node-sass-chokidar`在这里用于解决这些问题。\r\n","link":"如何在create-react-app中使用sass.html","preview":"create-react-app 中配置 sass。","title":"如何在create-react-app中使用sass"},{"content":"\r\n\r\n使用css3做的一些效果图。\r\n\r\n---\r\n\r\n[演示](https://yasinchan.com/just_code/css3/loading.html)\r\n\r\n---- \r\n\r\n[演示](https://yasinchan.com/just_code/css3/loading2.html)\r\n\r\n----\r\n\r\n[演示](https://yasinchan.com/just_code/css3/%e6%95%88%e6%9e%9c.html)\r\n\r\n----\r\n\r\n一个使用html/css 画的哆唻a梦 ~\r\n\r\n[演示](https://yasinchan.com/just_code/css3/index.html)","link":"css3.html","preview":"css3 demo。","title":"css3 效果图"},{"content":"\r\n\r\n[演示](https://yasinchan.com/just_code/resume/%e6%a8%a1%e5%9d%97%e5%8c%96/%e6%a8%a1%e5%9d%97%e5%8c%96.html)\r\n\r\n[代码地址](https://github.com/yasinchan/just_code/tree/master/resume/%e6%a8%a1%e5%9d%97%e5%8c%96)\r\n\r\n这个demo中使用了`carousel`,`exposure`,`gotop`,`waterfall`(后端使用server-mock进行mock数据) 在内的多个组件，这些组件使用了js面向对象编程；使用了require.js对代码进行了模块化管理。最后，使用了r.js进行了打包，打包文件为 `index.merge.min.js` 文件。\r\n\r\n\r\n---- \r\n\r\n[代码](https://github.com/yasinchan/just_code/tree/master/resume/webpack-demo)\r\n\r\n这是使用webpack对以上演示进行模块化管理的代码。","link":"模块化.html","preview":"一个小demo。","title":"模块化管理 demo"},{"content":"\r\n\r\n### 原型链相关问题\r\n\r\n**问题1：**有如下代码，解释`person`、 `prototype`、`__proto__`、`p`、`constructor`之间的关联。\r\n\r\n```\r\nfunction person(name){\r\n    this.name = name;\r\n}\r\nperson.prototype.sayname = function(){\r\n    console.log('my name is :' + this.name);\r\n}\r\nvar p = new person(\"若愚\")\r\np.sayname();\r\n```\r\n\r\n`preson`是构造函数，也是一个对象。\r\n\r\n`p`为`person`的实例，拥有`person`原型链上的属性和方法\r\n\r\n`p.__proto__`指向`person.prototype`\r\n\r\n`person.prototype.constructor`指向`person`\r\n\r\n\r\n\r\n\r\n\r\n**问题2：** 上例中，对对象 p可以这样调用 `p.tostring()`。`tostring`是哪里来的? 画出原型图?并解释什么是原型链。\r\n\r\n![](/images/原型链.png)\r\n\r\n可以从原型图中看出`tostring`是`object.prototype`的方法，`p`先通过`p.__proto__` 找`person.prototype`中的方法，然而没找到。然后接着`p.__proto__.__proto__`就找到了。\r\n\r\n\r\n\r\n原型链：由于原型对象本身也是对象，而每个`javascript`对象都有一个原型对象，每个对象都有一个隐藏的`__proto__`属性，原型对象也有自己的原型，而它自己的原型对象又可以有自己的原型，这样就组成了一条链，这个就是原型链。在访问对象的属性时，如果在对象本身中没有找到，则会去原型链中查找，如果找到，直接返回值，如果整个链都遍历且没有找到属性，则返回`undefined`。原型链一般实现为一个链表，这样就可以按照一定的顺序来查找。\r\n\r\n**问题3：**对`string`做扩展，实现如下方式获取字符串中频率最高的字符\r\n\r\n```\r\nvar str = 'ahbbccdeddddfg';\r\nvar ch = str.getmostoften();\r\nconsole.log(ch); //d , 因为d 出现了5次\r\n```\r\n\r\n```\r\nstring.prototype.getmostoften = function(){\r\n    var obj = {};\r\n    for(var i=0;i\u003cthis.length;i++){\r\n        var n = this[i];\r\n        if(obj[n]){\r\n            obj[n]++\r\n        }else{\r\n            obj[n] = 1\r\n        }\r\n    }\r\n    var max = 0,\r\n    \tkey;\r\n    for(var n in obj){\r\n        if(obj[n]\u003emax){\r\n           max = obj[n];\r\n           key = n;\r\n        }\r\n     }\r\n    return key;\r\n}\r\nvar str = 'ahbbccdeddddfg';\r\nvar ch = str.getmostoften();\r\nconsole.log(ch); \r\n```\r\n\r\n\r\n\r\n\r\n\r\n**问题4：** `instanceof`有什么作用？内部逻辑是如何实现的？\r\n\r\ninstanceof 是一个运算符。`a instanceof b`用于判断a 是否是b 的一个实例，或者是a是否是以b为父类型的一个实例。\r\n\r\n内部逻辑：`instanceof`相当于如下函数`isinstanceof`\r\n\r\n```\r\nfunction isinstanceof(obj, fn){\r\n\tvar oldproto = obj.__proto__;\r\n\tdo{\r\n\t\tif(oldproto === fn.prototype){\r\n\t\t\treturn true;\r\n\t\t}else{\r\n\t\t\toldproto = oldproto.__proto__;\r\n\t\t\tconsole.log(oldproto);\r\n\t\t}\r\n\t}while(oldproto) \r\n\treturn false;\r\n}\r\n```\r\n\r\n\r\n\r\n### 继承相关问题\r\n\r\n**问题1：**继承有什么作用?\r\n\r\n继承可以使一个对象直接使用另一个对象的方法和属性。可以重写和扩展父类的属性和代码，又不影响父类本身。\r\n\r\n\r\n\r\n**问题2：** 下面两种写法有什么区别?\r\n\r\n```\r\n//方法1\r\nfunction people(name, sex){\r\n    this.name = name;\r\n    this.sex = sex;\r\n    this.printname = function(){\r\n        console.log(this.name);\r\n    }\r\n}\r\nvar p1 = new people('饥人谷', 2)\r\n\r\n//方法2\r\nfunction person(name, sex){\r\n    this.name = name;\r\n    this.sex = sex;\r\n}\r\n\r\nperson.prototype.printname = function(){\r\n    console.log(this.name);\r\n}\r\nvar p1 = new person('若愚', 27);\r\n```\r\n![](/images/问题2-1.png)\r\n![](/images/问题2-2.png)\r\n\r\n\r\n从上两图可以看出：方法一的写法是属性方法都写入`p1`中；方法二中的`p1`只有属性`name`和`sex`，方法绑定在`person.prototype`属性下，`p1`可以继承父类的属性和方法。这样做的好处是节约代码量，提高性能。\r\n\r\n\r\n\r\n**问题3：** `object.create` 有什么作用？兼容性如何？\r\n\r\n`object.create()`创建一个具有指定原型且可选择性地包含指定属性的对象。可以通过`object.create()`方法实现类式继承，如：\r\n\r\n```\r\nmale.prototype = object.create(person.prototype);\r\n```\r\n\r\n通过`object.create()` `clone`了一个新的`prototype`，使`male.prototype`指向这个新的`prototype`，而不是直接将`person.prototype`赋值给它，这样做可以避免当修改`male.prototype`的时候不会将它的父类`person.prototype`也修改了。\r\n\r\n兼容性：\r\n\r\n![](/images/兼容性.png)\r\n\r\n[来源](http://caniuse.com/)\r\n\r\n**问题4：** `hasownproperty`有什么作用？ 如何使用？\r\n\r\n作用：`hasownperperty`是`object.prototype`的一个方法，可以判断一个对象是否包含自定义属性而不是原型链上的属性，`hasownproperty`是`javascript`中唯一一个处理属性但是不查找原型链的函数。\r\n\r\n使用：`m.hasownproperty('name'); `\r\n`m.hasownproperty('printname'); `\r\n`male.prototype.hasownproperty('printage');`\r\n\r\n\r\n\r\n**问题5：**如下代码中`call`的作用是什么?\r\n\r\n```\r\nfunction person(name, sex){\r\n    this.name = name;\r\n    this.sex = sex;\r\n}\r\nfunction male(name, sex, age){\r\n    person.call(this, name, sex);    //这里的 call 有什么作用\r\n    this.age = age;\r\n}\r\n```\r\n\r\n上文说道`call`可以指定函数的`this` ，所以这里的`call`指定`person`中的`this`为`male`。从而让函数`male`可以调用`person`的属性。\r\n\r\n\r\n\r\n**问题6：** 补全代码，实现继承 \r\n\r\n```\r\nfunction person(name, sex){\r\n    this.name = name;\r\n    this.sex = sex;\r\n    this.printname = function(){\r\n    \tconsole.log(name)\r\n    }\r\n}\r\n\r\nperson.prototype.getname = function(){\r\n    console.log(this.name)\r\n};    \r\n\r\nfunction male(name, sex, age){\r\n   person.call(this, name, sex);\r\n   this.age = age;\r\n}\r\n\r\nmale.prototype = object.create(person.prototype)\r\nmale.prototype.getage = function(){\r\n    console.log(this.age)\r\n};\r\n\r\nvar ruoyu = new male('若愚', '男', 27);\r\nruoyu.printname();\r\nruoyu.getage();\r\nruoyu.getname();\r\n```\r\n![](/images/继承.png)\r\n","link":"原型链\u0026继承.html","preview":"原型链和继承学习归纳。","title":"原型链\u0026继承"},{"content":"\n\n### 前言\n\nthis是javascript中的关键字之一，在编写程序的时候经常会用到，正确的理解和使用关键字this尤为重要。this 也让我们的代码更加优雅，但前提便是我们要理解她。\n\n\n\n这里推荐方方老师在知乎发的一篇关于[this](https://zhuanlan.zhihu.com/p/23804247?refer=study-fe)的解释很精辟，很值得学习。以下是我用一段代码来理解`this`。\n\n\n### 正文\n下面这段代码，涵盖了很多常见 this 使用的情况。我们可以通过分析这段代码中的 this 来理解 this 。\n\n```\n\u003cbody\u003e\n\t\n\u003cbutton id=\"btn\"\u003e点我\u003c/button\u003e\n\n\u003c/body\u003e\n\n\u003cscript\u003e\n\t\nvar app = {\n\tinit: function(){\n\t\tthis.target = document.queryselector('#btn');         // i\n\t\tthis.bind();                                          // i\n\t},\n\n\tbind: function(){\n\t\tvar _this = this;                                    //  j\n\n\t\tsettimeout(this.sayhaha, 2000);                      //  x\n\t\t\n\t\tthis.target.addeventlistener('click', function(){    //  i\n\t\t\tvar self = this;                                 \n\t\t\tthis.innertext = '我被点了';                  //  p\n\t\t\t_this.sayhello;\n\n\t\t\tsettimeout(function(){\n\t\t\t\tself.innertext = '点我';                       \n\t\t\t\tconsole.log(this);                   //  y\n\t\t\t\t_this.saygoodbye();\n\t\t\t}, 1000)\n\t\t});\n\t},\n\n\tsayhello: function(){\n\t\tconsole.log('hello');                                   \n\t\tconsole.log(this);                                   //  z\n\t},\n\tsaygoodbye: function(){\n\t\tconsole.log('goodbye');\n\t\tconsole.log(this);                                   //  z\n\t},\n\tsayhaha: function(){\n\t\tconsole.log('haha');\n\t\tconsole.log(this)                                    //  z\n\t}\n};\n\n\napp.init();\n\n\u003c/script\u003e\n```\n\n- 我用数字 i 、 j 、 p 、 x 、 y 、 z 来代指各处的`this`\n\n\n\n\n\n- 首先，我们可以轻易的看出 *i* 处的this指的就是 ` app  ` 这个对象； *p* 处的 `this` 指的是 `#btn`;\n\n\n\n- *j* 处用`var _this = this ` 此处`this`指的是`app`这个对象，通过赋值给`_this`。可以方便下面嵌套的函数调用。而且在以后对象名变换也不要用更改函数中的名字，减少出错概率。\n\n\n\n- 我们先来看 *y* 处的`this ` ，有个概念是`settimeout`中的`this`是全局对象，也就是`widow`，因为在使用`settimeout`的时候，js 会把里面的函数放在任务执行函数的最后，也就相当于是放到全局作用域中了。所以此时的`this`也就是指的是`window`了 。\n\n\n\n- 那么我们看下 *x* 处的`this`是不是也是指的是`window`呢？其实不是，这里的`this`也许会被误解为也是全局对象，但是其实是这样的：我们所说的`settimeout`中作为全局对象的`this`是指`settimeout`下匿名函数的`this`。而这里面的`this`并没有进入匿名函数中所以这里的`this`还是指`app`。\n\n\n\n- 最后的 *z* 处的`this`都是指的是`app`。因为`sayhello`被`_this`调用，`_this`指的是`app`所以此处的`this`指的是`app`。另外两个同理。\n\n\n","link":"this.html","preview":"问题整理","title":"this 理解"},{"content":"\r\n\r\n**实现一个`waterfall`效果**\r\n\r\n[演示](https://yasinchan.com/just_code/jquery/%e5%b8%83%e5%b1%80/%e7%80%91%e5%b8%83%e6%b5%81.html)\r\n\r\n**实现木桶布局效果**\r\n\r\n[演示](https://yasinchan.com/just_code/jquery/%e5%b8%83%e5%b1%80/%e6%9c%a8%e6%a1%b6%e5%b8%83%e5%b1%80.html)\r\n\r\n","link":"瀑布流+木桶布局.html","preview":"瀑布流和木桶布局学习归纳。","title":"瀑布流\u0026木桶布局"},{"content":"\n\n**问1：** jquery 中， $(document).ready()是什么意思？\n\n`$(document).ready()`：当dom加载完后执行js。也可以编写多个。简写为`(function(){})`。\n\n**问2：** $和node.html()和$node.text()的区别?\n\n`.html()` 是返回或设置所选元素的内容包括html标记。\n\n`.text()` 是返回或设置所选元素的文本内容。\n\n相当于原生js中的`.innerhtml()` 和 `.innertext()`\n\n**问3：** $.extend 的作用和用法? \n\n作用：将多个对象合并到第一个对象上。\n\n用法：\n\n![](/images/3.png)\n\n**问4：** jquery 的链式调用是什么？\n\n使用jquery方法时，对象的方法返回的是对象的本身，因此能接着使用本对象的其他jquery方法，这就是链式调用。链式调用可以提高代码效率，使代码更优雅。如：\n\n`$div.slidedown().fadeout();`\n\n**问5：** jquery 中 data 函数的作用\n\n作用：作用：实际上是对js对象或dom对象的额外属性做一个集中管理，来避免内存泄漏\n\n**问6：**\n\n- 写出以下功能对应的 jquery 方法：\n  - 给元素 $添加，给元素node 添加 class `active`，给元素 $noed 删除 class `active`\n  - 展示元素$隐藏元素node, 隐藏元素$node\n  - 获取元素$node 的 属性: id、src、title， 修改以上属性\n  - 给$node 添加自定义属性`data-src`\n  - 在$内部最开头添加元素ct 内部最开头添加元素$node\n  - 在$内部最末尾添加元素ct 内部最末尾添加元素$node\n  - 删除$node\n  - 把$ct里内容清空\n  - 在$ct 里设置 html ``\n  - 获取、设置$node 的宽度、高度(分别不包括内边距、包括内边距、包括边框、包括外边距)\n  - 获取窗口滚动条垂直滚动距离\n  - 获取$node 到根节点水平、垂直偏移距离\n  - 修改$node 的样式，字体颜色设置红色，字体大小设置14px\n  - 遍历节点，把每个节点里面的文本内容重复一遍\n  - 从$ct 里查找 class 为 `.item`的子元素\n  - 获取$ct 里面的所有孩子\n  - 对于$node，向上找到 class 为'.ct'的父亲，在从该父亲找到'.panel'的孩子\n  - 获取选择元素的数量\n  - 获取当前元素在兄弟中的排行\n\n**问7：**\n\n- 用jquery实现以下操作\n  - 当点击$时，让btn 时，让 $btn 的背景色变为红色再变为蓝色\n  - 当窗口滚动时，获取垂直滚动距离\n  - 当鼠标放置到$上，把div 上，把$div 背景色改为红色，移出鼠标背景色变为白色\n  - 当鼠标激活 input 输入框时让输入框边框变为蓝色，当输入框内容改变时把输入框里的文字小写变为大写，当输入框失去焦点时去掉边框蓝色，控制台展示输入框里的文字\n  - 当选择 select 后，获取用户选择的内容\n\n  [演示](https://yasinchan.com/just_code/jquery/question7/7.html)  \n\n  使用了 jquery 和 jquery-ui\n\n**问8：** 用 jquery ajax 实现一个 `loadmore`\n\n后端在本地使用server-mock来 mock 数据\n\n[演示](https://yasinchan.com/just_code/jquery/loadmore/loadmore-jq.html)\n\n[代码](https://github.com/yasinchan/just_code/tree/master/jquery/loadmore)\n\n![](/images/8.png)","link":"jquery-ajax.html","preview":"jquery-ajax学习归纳。","title":"jquery-ajax"},{"content":"\r\n\r\n### 前言\r\n最近配置xampp过程中遇到apache点击start却无法开启，google后发现也有很多人遇到这种情况。查阅许久，问题成功解决。\r\n\r\n#### 解决方法\r\n当我们打开xammp时，我们点击apache中的start却无法开启，下面报错\r\n```\r\n[apache]  error: apache shutdown unexpectedly.\r\n[apache]  this may be due to a blocked port, missing dependencies, \r\n[apache]  improper privileges, a crash, or a shutdown by another method.\r\n[apache]  press the logs button to view error logs and check\r\n[apache]  the windows event viewer for more clues\r\n[apache]  if you need more help, copy and post this\r\n[apache]  entire log window on the forums\r\n```\r\n此时，我们可以打开`g:\\xampp\\apache\\conf`(g:\\xampp是我的安装目录)下找到`httpd.conf`文件，可以用sublime打开后找到\r\n```\r\nlisten80\r\n```\r\n\r\n```\r\nservername localhost:80\r\n```\r\n\r\n将其中的80改为8080\r\n\r\n[来源](http://stackoverflow.com/questions/18300377/xampp-apache-error-apache-shutdown-unexpectedly)\r\n\r\nps: 原文中还有一个步骤，翻译过来就是：\r\n打开`httpd-ssl.conf`找到\r\n```\r\nlisten 443\r\n```\r\n\r\n```\r\nvirtualhost _default_:443\r\nservername localhost:443\r\n```\r\n\r\n将其中的443改为4433。\r\n但是我发现不做这一步也没有问题。\r\n\r\n\r\n此时我们重新开启apache，发现可以开启，但是却出现以下的问题\r\n```\r\n[apache]  problem detected!\r\n[apache]  port 80 in use by \u0026quot;unable to open process\u0026quot; with pid 4!\r\n[apache]  apache will not start without the configured ports free!\r\n[apache]  you need to uninstall/disable/reconfigure the blocking application\r\n[apache]  or reconfigure apache and the control panel to listen on a different port\r\n```\r\n\r\n此时，我们可以运行对话框（按win + r键）键入：`services.msc`\r\n\r\n出现如下界面：\r\n\r\n![](/images/服务.png)\r\n\r\n找到箭头所指后右键关闭。\r\n\r\n[来源](http://stackoverflow.com/questions/20558410/xampp-port-80-in-use-by-unable-to-open-process-with-pid-4-12)\r\n\r\n此时我们重启apache发现问题解决。\r\n\r\n将我们需要的php文件放入`g:\\xampp\\htdocs`文件夹下在浏览器打开`localhost:8080/文件名.php`即可访问我们php文件。\r\n\r\n\r\nps：如果设置过程中还出现其他问题，可以点击我的文中的`来源`，看各个步骤完整的解决方法。","link":"xampp安装过程中问题解决方法.html","preview":"问题整理","title":"xampp安装过程中问题的解决方法"},{"content":"\r\n\r\n## 楔子\r\n最近做的一道百度ife中的题目遇到关于tab切换，而本人还没学到js，从而需要用css写出tab切换[demo](http://yasinchan.com/testfirststage/test9/test9.html) css见[github](https://github.com/yasinchan/testfirststage/blob/master/test9/test9.css) `从578至665行`\r\n\r\n### table\r\n\r\ntable中我们可以加入如下的css来使表格中的线为一根线\r\n``` yaml\r\nhtml:\r\n   \u003ctable border=\"1\"\u003e\u003c/table\u003e\r\ncss:\r\n   table{\r\n        border-collapse:collase;\r\n        border-spacing;\r\n   }   \r\n```\r\n\r\n### 问：css中的~是什么？\r\n\r\n这是 `css3 element1~element2 选择器`\r\n\r\n定义和用法\r\n　　element1~element2 选择器 element1 之后出现的所有 element2。\r\n　　两种元素必须拥有相同的父元素，但是 element2 不必直接紧随 element1。\r\n\r\n实例：\r\n为所有相同的父元素中位于 p 元素之后的所有 ul 元素设置背景：\r\n``` yaml\r\n    p~ul{\r\n        background:#ff0000;\r\n    }\r\n```\r\n\r\n来源：[https://zhidao.baidu.com/question/1691564837342076508.html](https://zhidao.baidu.com/question/1691564837342076508.html)\r\n\r\n\r\n### 问：class^=,class*= ,class$=含义\r\n``` yaml\r\n\u003cdiv class=\"xxx\"\u003e\r\n    \u003cdiv class=\"span\"\u003e\u003c/span\u003e         \u003c!-- 1--\u003e\r\n    \u003cdiv class=\"spanabc\"\u003e\u003c/span\u003e      \u003c!-- 2--\u003e\r\n    \u003cdiv class=\"abcspan\"\u003e\u003c/span\u003e      \u003c!-- 3--\u003e\r\n    \u003cdiv class=\"abcspanabc\"\u003e\u003c/span\u003e   \u003c!-- 4--\u003e\r\n\u003c/div\u003e\r\n```\r\n\r\n.xxx [class*=\"span\"] 是指.xxx里面所有的包含span的选择器即以上四个都是\r\n\r\n.xxx [class^=\"span\"] 是指.xxx里面以span开头的即1 2是\r\n\r\n.xxx [class$=\"span\"] 是指.xxx里面以span结尾的即1 3是\r\n \r\n\r\n### :checked 是什么？\r\n这是伪类选择器\r\n匹配每个已被选中的 input 元素（只用于单选按钮和复选框）。\r\n\r\n来源： [w3school](http://www.w3school.com.cn/cssref/selector_checked.asp)\r\n\r\n\r\n### 问：z-index在css中怎么用？\r\n\r\n答1：\r\n当你定义的css中有position属性值为absolute、relative或fixed，\r\n\r\n用z-index此取值方可生效。\r\n此属性参数值越大，则被层叠在最上面。\r\n例子：\r\n\r\n``` yaml\r\n\u003chtml\u003e\r\n\u003chead\u003e\r\n\u003cstyle\u003e\r\n.z1,.z2,.z3{position:absolute;width:200px;height:100px;padding:5px 10px;color:#fff;text-align:right;}\r\n.z1{z-index:1;background:#000;}\r\n.z2{z-index:2;top:30px;left:30px;background:#c00;}\r\n.z3{z-index:3;top:60px;left:60px;background:#999;}\r\n\u003c/style\u003e\r\n\u003c/head\u003e\r\n\u003cbody\u003e\r\n\u003cdiv class=\"z1\"\u003ez-index:1\u003c/div\u003e\r\n\u003cdiv class=\"z2\"\u003ez-index:2\u003c/div\u003e\r\n\u003cdiv class=\"z3\"\u003ez-index:3\u003c/div\u003e\r\n\u003c/body\u003e\r\n\u003c/html\u003e\r\n```\r\n\r\n上面三个css，将根据z-index的值决定谁在最上层！\r\n\r\n答2：\r\nz-index就是网页的z轴，用相对定位绝对定位把两个层重叠在一起，z-index的值越大，就越靠上，注意，z-index没有单位，z-index：99；这样写就够了\r\n\r\n来源：[https://zhidao.baidu.com/question/416073543.html](https://zhidao.baidu.com/question/416073543.html)\r\n\r\n\r\n","link":"纯css实现tab切换中遇到的问题.html","preview":"解决方法","title":"纯css实现tab切换中遇到的问题"},{"content":"\r\n\r\n## overflow：hidden； 含义\r\n\r\n来源：[http://jingyan.baidu.com/article/d45ad148e2a7f969552b80ae.html](http://jingyan.baidu.com/article/d45ad148e2a7f969552b80ae.html)\r\n\r\noverflow:hidden这个css样式是大家常用到的css样式，但是大多数人对这个样式的理解仅仅局限于隐藏溢出，而对于清除浮动这个含义不是很了解。一提到清除浮动，我们就会想到另外一个css样式：clear:both，我相信对于这个属性的理解大家都不成问题的。但是对于“浮动”这个词到底包含什么样的含义呢？我们下面来详细的阐述一下。 \r\n\r\n这是一个常用的div写法，下面我们来书写样式。大家可以在dmx中自己做试验\r\n\r\n .box{ \r\n\r\n          width:500px; \r\n\r\n          background:#000; \r\n\r\n          height:500px;\r\n\r\n } \r\n\r\n .content { \r\n\r\n          float:left; \r\n\r\n          width:600px; \r\n\r\n          height:600px; \r\n\r\n          background:red;\r\n\r\n } \r\n\r\n　　给box这个div加了一个overflow:hidden这个属性解决了这个问题。我们直到overflow:hidden这个属性的作用是隐藏溢出，给box加上这个属性后，我们的content 的宽高自动的被隐藏掉了。另外，我们再做一个试验，将box这个div的高度值删除后，我们发现，box的高度自动的被content 这个div的高度值给撑开了。说到这里，我们再来理解一下“浮动”这个词的含义。我们原先的理解是，在一个平面上的浮动，但是通过这个试验，我们发现，这不仅仅是一个平面上的浮动，而是一个立体的浮动！也就是说，当content 这个div加上浮动这个属性的时候，在显示器的侧面，它已经脱离了box这个div，也就是说，此时的content 的宽高是多少，对于已经脱离了的box来说，都是不起作用的。当我们全面的理解了浮动这个词的含义的时候，我们就理解overflow:hidden这个属性中的解释，清除浮动是什么意思了。也就是说，当我们给box这个div加上overflow:hidden这个属性的时候，其中的content 等等带浮动属性的div的在这个立体的浮动已经被清除了。这就是overflow:hidden这个属性清除浮动的准确含义。当我们没有给box这个div设置高度的时候，content 这个div的高度，就会撑开box这个div，而在另一个方面，我们要注意到的是，当我们给box这个div加上一个高度值，那么无论content 这个div的高度是多少，box这个高度都是我们设定的值。而当content 的高度超过box的高度的时候，超出的部分就会被隐藏。这就是隐藏溢出的含义！\r\n\r\n## overflow：hidden； 误解\r\n来源：作者：[小李刀刀](http://ofcss.com/2011/03/20/misunderstood-of-overflow-hidden.html)\r\n\r\n开始的时候，我认为这个属性使用会裁剪掉我的子元素。\r\n但事实是拥有overflow:hidden样式的块元素内部的元素溢出并不总是被隐藏，具体来说，需要同时满足以下条件：\r\n\r\n- 1.拥有overflow:hidden样式的块元素不具有position:relative和position:absolute样式；\r\n- 2.内部溢出的元素是通过position:absolute绝对定位； 如果你只关心结论，那么记住这两点就够了。\r\n\r\n也就是说爷爷相对定位，老爸规定溢出隐藏，可是儿子是绝对定位元素。这时候儿子是否隐藏由爷爷决定，而不是老爸。\r\n\r\n\r\n## 其他（深入理解流体特性和bfc特性下多栏自适应布局）\r\n来源：[张鑫旭](http://www.zhangxinxu.com/wordpress/tag/overflowhidden/)","link":"overflow：hidden.html","preview":"overflow：hidden； 含义与误解","title":"关于 overflow：hidden； 总结"},{"content":"\n\n## yasinchan简介\n\n在下陈耀耀，第一次做博客，紧张又兴奋。我会在博客中记录自己的成长，努力学习。\n![初来乍到请多关照](/images/img_2257.jpg)\n\n### 社交账号\n- 新浪微博：[耀耀大大帅哥](http://weibo.com/u/5669462960/)\n- github:[yasinchan](https://github.com/yasinchan/)\n- qq:867103198\n- 微信：cyy867103198\n- 邮箱：yasinchan2016@gmail.com\n\n### 特别鸣谢\n- [solarhell](https://solarhell.com/)给予我的帮助\n","link":"my first blog.html","preview":"初来乍到，请多关照。","title":"我的第一篇博客"}]